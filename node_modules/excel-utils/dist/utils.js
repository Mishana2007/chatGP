"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSharedFormulaOffsets(targetCell, sharedToRange) {
    const rangeStart = sharedToRange.split(':')[0];
    const { column: rangeStartCol, row: rangeStartRow } = splitCell(rangeStart);
    const { column: cellCol, row: cellRow } = splitCell(targetCell);
    const rowOffset = cellRow - rangeStartRow;
    const colOffset = encodeColumn(cellCol) - encodeColumn(rangeStartCol);
    return [colOffset, rowOffset];
}
exports.getSharedFormulaOffsets = getSharedFormulaOffsets;
function adjustDynamicCellReferences(formula, cell, range) {
    let rangeStart = range.split(':')[0];
    let [colOffset, rowOffset] = getSharedFormulaOffsets(cell, rangeStart);
    return formula.replace(/(\$?[A-Z]+)(\$?\d+)/g, function (match, col, row) {
        return `${shiftCol(col, colOffset)}${shiftRow(row, rowOffset)}`;
    });
}
exports.adjustDynamicCellReferences = adjustDynamicCellReferences;
const A = 'A'.charCodeAt(0);
function encodeColumn(column) {
    column = column.toUpperCase();
    let encoded = column.charCodeAt(column.length - 1) - A + 1;
    for (let i = column.length - 2; i >= 0; i--) {
        encoded =
            encoded +
                (column.charCodeAt(i) - A + 1) * Math.pow(26, column.length - i - 1);
    }
    return encoded;
}
exports.encodeColumn = encodeColumn;
function decodeColumn(column) {
    let codes = [];
    while (column > 26) {
        codes.unshift(A + ((column - 1) % 26));
        column = Math.ceil(column / 26) - 1;
    }
    codes.unshift(A + column - 1);
    return String.fromCharCode(...codes);
}
exports.decodeColumn = decodeColumn;
function shiftCol(col, offset) {
    return col.startsWith('$') ? col : decodeColumn(encodeColumn(col) + offset);
}
function shiftRow(row, offset) {
    return row.startsWith('$') ? row : +row + offset;
}
function splitCell(cellName) {
    let match = cellName.match(/([A-Z]+)([0-9]+)/);
    return { column: match[1], row: +match[2] };
}
//# sourceMappingURL=utils.js.map